/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "/workspaces/CPRE_550_Proj_1/include//rpc_service.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include "computation_threads.h"

static void
	rpc_prog_1(rqstp, transp) struct svc_req *rqstp;
register SVCXPRT *transp;
{
	union
	{
		long date_1_arg;
		long cpu_1_arg;
		long memory_1_arg;
		long processes_1_arg;
	} argument;
	char *result;
	bool_t (*_xdr_argument)(), (*_xdr_result)();
	char *(*local)();

	switch (rqstp->rq_proc)
	{
	case NULLPROC:
		(void)svc_sendreply(transp, (xdrproc_t)xdr_void, (char *)NULL);
		return;

	case DATE:
		_xdr_argument = xdr_long;
		_xdr_result = xdr_wrapstring;
		local = (char *(*)())date_1;
		break;

	case CPU:
		_xdr_argument = xdr_long;
		_xdr_result = xdr_float;
		local = (char *(*)())cpu_1;
		break;

	case MEMORY:
		_xdr_argument = xdr_long;
		_xdr_result = xdr_float;
		local = (char *(*)())memory_1;
		break;

	case PROCESSES:
		_xdr_argument = xdr_long;
		_xdr_result = xdr_wrapstring;
		local = (char *(*)())processes_1;
		break;

	default:
		svcerr_noproc(transp);
		return;
	}
	memset((char *)&argument, 0, sizeof(argument));
	if (!svc_getargs(transp, (xdrproc_t)_xdr_argument, (caddr_t)&argument))
	{
		svcerr_decode(transp);
		return;
	}
	result = (*local)(&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t)_xdr_result, result))
	{
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, (xdrproc_t)_xdr_argument, (caddr_t)&argument))
	{
		fprintf(stderr, "%s", "unable to free arguments");
		exit(1);
	}
	return;
}

// Create local storage for computation threads to update

float local_cpu_loading[4];
float *cpu_loading = local_cpu_loading;

float local_memory_loading[4];
float *memory_loading = local_memory_loading;

float local_active_processes[4];
float *active_processes = local_active_processes;

pthread_mutex_t cpu_lock;
pthread_mutex_t memory_lock;
pthread_mutex_t processes_lock;

pthread_mutex_t *cpu_lock_ptr = &cpu_lock;
pthread_mutex_t *memory_lock_ptr = &memory_lock;
pthread_mutex_t *processes_lock_ptr = &processes_lock;

int main(argc, argv)
int argc;
char **argv;
{
	register SVCXPRT *transp;

	pmap_unset(RPC_PROG, INIT_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL)
	{
		fprintf(stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, RPC_PROG, INIT_VERS, rpc_prog_1, IPPROTO_UDP))
	{
		fprintf(stderr, "%s", "unable to register (RPC_PROG, INIT_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL)
	{
		fprintf(stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, RPC_PROG, INIT_VERS, rpc_prog_1, IPPROTO_TCP))
	{
		fprintf(stderr, "%s", "unable to register (RPC_PROG, INIT_VERS, tcp).");
		exit(1);
	}

	//===================================================================
	pthread_mutex_init(cpu_lock_ptr, NULL);
	pthread_mutex_init(memory_lock_ptr, NULL);
	pthread_mutex_init(processes_lock_ptr, NULL);

	struct thread_args *cpu_args = (struct thread_args *)malloc(sizeof(struct thread_args));
	struct thread_args *memory_args = (struct thread_args *)malloc(sizeof(struct thread_args));
	struct thread_args *processes_args = (struct thread_args *)malloc(sizeof(struct thread_args));

	cpu_args->data_ptr = cpu_loading;
	cpu_args->lock = cpu_lock_ptr;

	memory_args->data_ptr = memory_loading;
	memory_args->lock = memory_lock_ptr;

	processes_args->data_ptr = active_processes;
	processes_args->lock = processes_lock_ptr;

	pthread_t cpu_thread;
	pthread_t memory_thread;
	pthread_t processes_thread;

	pthread_create(&cpu_thread, NULL, cpu_computation, (void *)cpu_args);
	pthread_create(&memory_thread, NULL, memory_computation, (void *)memory_args);
	pthread_create(&processes_thread, NULL, processes_computation, (void *)processes_args);

	//===================================================================

	svc_run();
	fprintf(stderr, "%s", "svc_run returned");
	exit(1);
	/* NOTREACHED */
}
