/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "/workspaces/CPRE_550_Proj_1/include//rpc_service.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include "computation_threads.h"

static void
	rpc_prog_1(rqstp, transp) struct svc_req *rqstp;
register SVCXPRT *transp;
{
	union
	{
		long date_1_arg;
		long cpu_1_arg;
		long memory_1_arg;
		long processes_1_arg;
	} argument;
	char *result;
	bool_t (*_xdr_argument)(), (*_xdr_result)();
	char *(*local)();

	switch (rqstp->rq_proc)
	{
	case NULLPROC:
		(void)svc_sendreply(transp, (xdrproc_t)xdr_void, (char *)NULL);
		return;

	case DATE:
		_xdr_argument = xdr_long;
		_xdr_result = xdr_wrapstring;
		local = (char *(*)())date_1;
		break;

	case CPU:
		_xdr_argument = xdr_long;
		_xdr_result = xdr_float;
		local = (char *(*)())cpu_1;
		break;

	case MEMORY:
		_xdr_argument = xdr_long;
		_xdr_result = xdr_float;
		local = (char *(*)())memory_1;
		break;

	case PROCESSES:
		_xdr_argument = xdr_long;
		_xdr_result = xdr_wrapstring;
		local = (char *(*)())processes_1;
		break;

	default:
		svcerr_noproc(transp);
		return;
	}
	memset((char *)&argument, 0, sizeof(argument));
	if (!svc_getargs(transp, (xdrproc_t)_xdr_argument, (caddr_t)&argument))
	{
		svcerr_decode(transp);
		return;
	}
	result = (*local)(&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t)_xdr_result, result))
	{
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, (xdrproc_t)_xdr_argument, (caddr_t)&argument))
	{
		fprintf(stderr, "%s", "unable to free arguments");
		exit(1);
	}
	return;
}

// Create local storage for computation threads to update

float local_cpu_loading[4];
float *cpu_loading = local_cpu_loading;

float local_memory_loading[4];
float *memory_loading = local_memory_loading;

float local_active_processes[4];
float *active_processes = local_active_processes;

void run_periodic(float *output_data, computation_func_ptr f)
{
	for (int i = 0; i < 4; i++)
	{
		output_data[i] = f();
	}

	int counter = 0;
	while (1)
	{
		int hour;
		int minute;
		int seconds;

		float hour_calc;
		float minute_calc;
		float seconds_calc;

		hour_calc = 0;
		for (hour = 0; hour < 24; hour++)
		{
			minute_calc = 0;
			for (minute = 0; minute < 60; minute++)
			{
				seconds_calc = 0;
				for (seconds = 0; seconds < 60; seconds += SLEEP_DURATION)
				{
					output_data[0] = f();
					seconds_calc += output_data[0];
					sleep(SLEEP_DURATION);
				}
				output_data[1] = seconds_calc / (60 / SLEEP_DURATION);
				minute_calc += output_data[1];
			}
			output_data[2] = minute_calc / 60;
			hour_calc += output_data[2];
		}
		output_data[3] = hour_calc / 24;
	}
}

float current_cpu_loading(void)
{
	return 1.0;
}

float current_memory_loading(void)
{
	return 1.0;
}

float current_processes(void)
{
	return 1.0;
}

void *cpu_tracker(void *args)
{
	run_periodic(cpu_loading, current_cpu_loading);
}

void *memory_computation(void *args)
{
	run_periodic(memory_loading, current_memory_loading);
}

void *processes_computation(void *args)
{
	run_periodic(active_processes, current_processes);
}

int main(argc, argv)
int argc;
char **argv;
{
	register SVCXPRT *transp;

	pmap_unset(RPC_PROG, INIT_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL)
	{
		fprintf(stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, RPC_PROG, INIT_VERS, rpc_prog_1, IPPROTO_UDP))
	{
		fprintf(stderr, "%s", "unable to register (RPC_PROG, INIT_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL)
	{
		fprintf(stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, RPC_PROG, INIT_VERS, rpc_prog_1, IPPROTO_TCP))
	{
		fprintf(stderr, "%s", "unable to register (RPC_PROG, INIT_VERS, tcp).");
		exit(1);
	}

	svc_run();
	fprintf(stderr, "%s", "svc_run returned");
	exit(1);
	/* NOTREACHED */
}
